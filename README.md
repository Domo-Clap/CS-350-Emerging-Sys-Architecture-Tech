# CS-350-Emerging-Sys-Architecture-Tech

# Summarize the project and what problem it was solving

-The final project I had to work on for this class revolved around me taking on the role of an embedded systems engineer trying to develop a prototype version of a smart thermostat for the company I work for called SysTec. In order to make this prototype version, I was primarily asked to focus on the development of code for a smart thermostat that read the temperature in the current room via a sensor on the TI SimpleLink Wi-Fi CC3220S development kit. The main purpose of the prototype was to create some basic code that could read the room temp, use an LED on a smart device to indicate that the heat for a house would be turned on or off, and simulate the data being sent to a cloud server. This prototype would pretty much show that SysTec, the company I would be working for, could get into the smart thermostat market. After developing the code for the prototype version of a smart thermostat, I then had to write a written report that explained and made recommendations on possible microcontrollers that could be used in a product version of the smart thermostat. Also, I did include a graph showing what some of the processes inside the code looked like in a task scheduler structure. 
    The problem I was solving was the need to create a prototype for the smart thermostat to show the basic functionality of it on a lower level. I also was solving the problem of supplying some recommendations for potential microcontrollers to be used in a product version.

# What did you do particularly well?

-Personally, there were portions in this project where I felt I did particularly well. Starting with the code, I feel that I did well with a few things. For one, I felt that the way I developed the state machines was good. The SMs were simple, but they made sure to achieve the necessary functionality. In relation to the requirements, they made it so the temperature was being checked, the LED was being switched when needed, and the button presses were being detected. I followed the lessons for state machines and made it so they used transition switches and action switches, which helped a lot when it came to separating where certain functionality happened. Another portion of the code I feel I did well with in terms of development was the way I implemented the output function. There were definitely some better ways I could have gone about it, such as creating a different Synch SM to handle the output to the terminal display and making it a task. But, with my knowledge at the time, I feel like I made it work well. The output display functionality involved me putting the display statement outside of the task scheduler. Instead, I made it so the output display statement was in the infinite timer loop under a conditional if statement to check the time passed. So, whenever the timer was running, every 1000ms the conditional statement would execute and display the correct info to the console. The last thing I felt I did particularly well in terms of the code was how I used comments as a form of documentation. I tried my best to explain everything related to the functionality of my code through comments placed throughout the code. I felt they were comprehensive and explained the functionality thoroughly.
    I also feel that I did very well with the written report of potential microprocessors. With the report, I made sure to do proper research for all three companies (TI, Microchip, and Freescale) in order to provide info related to real devices that could be viable options. With the research, I ensured that I explained each suggested product in terms of their RAM and Flash memory capabilites, as well as each product's peripheral support. I backed all of this explanation up with citations from each companies websites and device manuals. My reference page for the report included all of the sources I used to write a comprehensive report on the matter. As for my recommendation, I mostly used my personal development experience as the main bias, as all three products I suggested were extremely similar in terms of peripheral support and other capabilities.
    
# Where could you improve?

-Like I mentioned in the prior question, there was one major place in the code where I felt I could improve certain things. This was in regard to the output to terminal display functionality. I most likely could have implemented this functionality via a SM that was used in the task scheduler, instead of a conditional statement in the timer loop. This change would have definitely made things more consistent. However, at the time, I was mostly just happy everything was working and I was too beyond it already to spend the time trying to change it. Also, from what the professor mentioned, I should have initialized my task list statically, as it would have reduced the amount of code. Another area where I could improve in terms of the project was the depth of my report. Personally, even though I feel my report was good, there was definitely room for improvement. For one, I could have definitely spent a bit more time and researched more products that could have been potential options. I also could have went into more depth in terms of recommendation reasons such as price, certain performance specs, and even development support. And lastly, I feel that I could have done better with my Task Scheduler diagram. At the time, I did not really have a good idea of what I was trying to create for the diagram, so I mostly went out on a limb and made what I thought was good enough. But in hindsight, I wish I would have done a bit more research on what a task scheduler diagram should look like, so that it could have been more comprehensive.

# What tools and/or resources are you adding to your support network?

-Currently, a lot of my support network relies on things like school textbooks, stack-exchange, google, and other people I know. From this course, I feel like I have really started to embrace the idea that if I am confused on something, it is okay to reach out and ask for clarification. The professor was there to guide me a few times, which definitely helped me get a better idea of what I was doing. Also, reaching out to other students was very useful to me. I was able to gain some insight on where I might be having errors, which helped quite a bit. So, I do think that from now on, if I don't understand something with my projects, and I have reached the point where researching has not led to an answer. I will ask others that are there to help me if needed. Sometimes, it is okay to reach out to others and ask for help! Also, I will be adding manuals for certain things to my support network. When working with some of the code for the project, there were times when I needed to know something specifically related to the IDE or the actual microcontroller board. Looking at the user manual for the board and IDE really helped me in these instances.

# What skills from this project will be particularly transferable to other projects and/or course work?

    There are a few skills that I gained or honed from this project that I feel will be transferable in some way to other projects. The first one that comes to mind is the process of building something up in pieces. I have already learned this skill from prior courses and projects, but this course project has really engrained it within me that starting out small, and building on top of the concepts or basics we already have laid out is a good way to work towards a final goal. With the project, I started by honing my skills using UART, GPIO, and timers. All of these skills helped me in the final project where I had to combine my knowledge of all three. Another skill that comes to mind is the extra practice I got with the C programming language. In terms of C languages, I have only ever written in C++ and C#, so this was a partially new experience for me. Either way, the extra practice with a C language will be very beneficial. The last skill that comes to mind is the ability to find errors in my code and fix them. This is a skill I have been practicing for a decent amount of time now, and I feel I have gotten a lot better at it over my past few courses. (Especially these last two terms) The coding involved in this class helped me improve this skill a lot, as there were many moments where I was stuck trying to get my code to work properly. Also, the extra knowledge I gained from this course regarding embedded systems is something I will never forget!

# How did you make this project maintainable, readable, and adaptable?

-In order to make this project maintainable, I tried my best to keep things organzied in my code, while also making sure to give myself proper amounts of time to work on said code. Earlier in the term, I managed my time pretty poorly when it came to the milestone coding assignments. However, with the final project, I tried to give myself a head start the week prior by starting the coding work then. As the final project due date drew closer, I made sure to work a little bit each day, and then spent two full days ensuring everything was all good in terms of functionality and documentation.
    As for readability, I made sure to include proper spacing throughout my code, as well as proper documentation related to the functionalities. I also tried my best to keep up a consistent format for variables, SM names, function names, etc...
    And as for adaptability, I started off by making certain parts of my code to be reuseable throughout the entire code. This included some of the task related code and the button callbacks code. The way the timer was set up could also be considered adaptable because it would be possible to use a lot of the same timer code for another project involving a timer. The same could be said for the state machine structure I used as well. Also, because we were using peripherals like GPIO and UART, there were some parts of the code that were easily adaptable and reuseable throughout the code. (I am talking about the LED_ON/LED_OFF statements for GPIO)
